<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <title>在线中国象棋对战 - @DESLET</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- 引入 PeerJS 实现 P2P 联机 -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
      * { box-sizing: border-box; margin: 0; padding: 0; }
      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        background: radial-gradient(circle at top, #fdfbfb 0, #ebedee 55%, #d7dde8 100%);
        min-height: 100vh;
        display: flex;
        align-items: stretch;
        justify-content: center;
        color: #222;
      }
      .app {
        display: flex;
        flex-direction: column;
        max-width: 1100px;
        width: 100%;
        margin: 16px;
        background: rgba(255, 255, 255, 0.9);
        border-radius: 16px;
        box-shadow: 0 18px 45px rgba(15, 23, 42, 0.18);
        overflow: hidden;
      }
      header {
        padding: 12px 20px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        border-bottom: 1px solid rgba(148, 163, 184, 0.4);
        backdrop-filter: blur(10px);
      }
      header .title {
        font-size: 18px;
        font-weight: 600;
        letter-spacing: 0.04em;
      }
      header .watermark {
        font-size: 12px;
        color: #64748b;
        letter-spacing: 0.08em;
        text-transform: uppercase;
      }
      main {
        display: grid;
        grid-template-columns: minmax(0, 3fr) minmax(260px, 2fr);
        gap: 0;
      }
      @media (max-width: 900px) {
        main { grid-template-columns: 1fr; }
      }
      .board-wrapper {
        padding: 16px 20px 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }
      .board-container {
        position: relative;
        width: min(520px, 100%);
        aspect-ratio: 9 / 10;
        background: #f8fafc;
        border-radius: 18px;
        padding: 10px;
        box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.35);
      }
      .board-grid {
        position: absolute;
        inset: 10px;
        display: grid;
        grid-template-columns: repeat(9, 1fr);
        grid-template-rows: repeat(10, 1fr);
      }
      .cell-border {
        border: 1px solid rgba(148, 163, 184, 0.7);
        border-radius: 1px;
      }
      .river {
        position: absolute;
        left: 10px;
        right: 10px;
        top: 50%;
        height: 10%;
        background: linear-gradient(180deg, rgba(191, 219, 254, 0.45), rgba(191, 219, 254, 0.1));
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: min(28px, 4vw);
        color: rgba(148, 163, 184, 0.7);
        pointer-events: none;
      }
      .river span { letter-spacing: 0.25em; }
      .pieces-layer {
        position: absolute;
        inset: 10px;
        display: grid;
        grid-template-columns: repeat(9, 1fr);
        grid-template-rows: repeat(10, 1fr);
      }
      .cell {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .piece {
        width: 80%;
        height: 80%;
        max-width: 54px;
        max-height: 54px;
        border-radius: 999px;
        background: radial-gradient(circle at 30% 20%, #f9fafb, #e5e7eb 45%, #cbd5f5 100%);
        box-shadow:
          0 2px 5px rgba(15, 23, 42, 0.3),
          inset 0 0 0 1px rgba(15, 23, 42, 0.35);
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 700;
        cursor: pointer;
        user-select: none;
        transition: transform 0.12s ease, box-shadow 0.12s ease, background 0.12s ease;
      }
      .piece.red { color: #b91c1c; }
      .piece.black { color: #111827; }
      .piece.selected {
        transform: translateY(-2px) scale(1.04);
        box-shadow:
          0 6px 16px rgba(59, 130, 246, 0.4),
          inset 0 0 0 1px rgba(37, 99, 235, 0.8);
      }
      .piece.enemy-turn { cursor: not-allowed; opacity: 0.8; }
      .piece-label {
        font-size: clamp(18px, 3vw, 24px);
      }
      .turn-indicator {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
        margin-top: 12px;
        font-size: 14px;
        color: #475569;
      }
      .dot {
        width: 9px;
        height: 9px;
        border-radius: 999px;
        background: #22c55e;
        box-shadow: 0 0 0 6px rgba(34, 197, 94, 0.25);
      }
      .turn-red .dot { background: #ef4444; box-shadow: 0 0 0 6px rgba(239, 68, 68, 0.25); }
      .turn-black .dot { background: #111827; box-shadow: 0 0 0 6px rgba(15, 23, 42, 0.35); }

      .side-panel {
        padding: 16px 18px 18px;
        border-left: 1px solid rgba(148, 163, 184, 0.35);
        background: linear-gradient(180deg, rgba(248, 250, 252, 0.95), rgba(241, 245, 249, 0.98));
        display: flex;
        flex-direction: column;
        gap: 14px;
      }
      @media (max-width: 900px) {
        .side-panel { border-left: none; border-top: 1px solid rgba(148, 163, 184, 0.35); }
      }
      .section-title {
        font-size: 13px;
        letter-spacing: 0.16em;
        color: #64748b;
        text-transform: uppercase;
      }
      .room-controls, .game-controls {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-top: 4px;
      }
      label {
        font-size: 13px;
        color: #475569;
      }
      input[type="text"] {
        width: 100%;
        padding: 7px 10px;
        border-radius: 9px;
        border: 1px solid rgba(148, 163, 184, 0.8);
        background: rgba(255, 255, 255, 0.9);
        font-size: 13px;
        outline: none;
        transition: border-color 0.12s ease, box-shadow 0.12s ease, background 0.12s ease;
      }
      input[type="text"]:focus {
        border-color: #2563eb;
        box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.4);
        background: #ffffff;
      }
      .button-row {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }
      button {
        padding: 6px 12px;
        border-radius: 999px;
        border: none;
        background: #0f172a;
        color: #f9fafb;
        font-size: 13px;
        font-weight: 500;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 4px;
        white-space: nowrap;
        transition: background 0.12s ease, transform 0.08s ease, box-shadow 0.12s ease, opacity 0.12s ease;
      }
      button.secondary { background: #e2e8f0; color: #0f172a; }
      button.danger { background: #b91c1c; }
      button.small { padding: 4px 9px; font-size: 12px; }
      button:disabled {
        opacity: 0.55;
        cursor: not-allowed;
        box-shadow: none;
        transform: none;
      }
      button:not(:disabled):hover { background: #020617; }
      button.secondary:not(:disabled):hover { background: #cbd5f5; }
      button.danger:not(:disabled):hover { background: #991b1b; }
      button:not(:disabled):active { transform: translateY(1px); box-shadow: none; }
      .hint {
        font-size: 12px;
        color: #64748b;
      }
      .log {
        flex: 1;
        min-height: 120px;
        max-height: 220px;
        overflow: auto;
        padding: 8px 10px;
        border-radius: 10px;
        border: 1px solid rgba(148, 163, 184, 0.6);
        background: rgba(15, 23, 42, 0.92);
        color: #e5e7eb;
        font-size: 12px;
        line-height: 1.4;
      }
      .log-line { opacity: 0.92; }
      .log-line span.time { color: #64748b; margin-right: 6px; }
      .log-line span.tag { color: #22c55e; margin-right: 4px; }
      .capsule-row {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        font-size: 12px;
      }
      .pill {
        padding: 3px 8px;
        border-radius: 999px;
        background: #e5e7eb;
        color: #0f172a;
      }
      .pill.red { background: #fee2e2; color: #b91c1c; }
      .pill.black { background: #e5e7eb; color: #111827; }
      .pill.muted { background: #e5e7eb; color: #6b7280; }
      .section {
        padding-top: 4px;
        padding-bottom: 4px;
        border-top: 1px dashed rgba(148, 163, 184, 0.4);
      }
      .section:first-of-type { border-top: none; }
      .footer-note {
        margin-top: 4px;
        font-size: 11px;
        color: #94a3b8;
      }
      .online-badge {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        font-size: 11px;
        color: #22c55e;
        margin-left: 8px;
      }
      .online-badge.offline { color: #94a3b8; }
      .online-dot {
        width: 6px;
        height: 6px;
        border-radius: 50%;
        background: currentColor;
      }
    </style>
  </head>
  <body>
    <div class="app">
      <header>
        <div class="title">
            在线中国象棋对战
            <span id="connection-status" class="online-badge offline">
                <span class="online-dot"></span>
                <span>离线</span>
            </span>
        </div>
        <div class="watermark">@DESLET</div>
      </header>
      <main>
        <section class="board-wrapper">
          <div class="board-container">
            <div class="board-grid" id="board-grid"></div>
            <div class="river"><span>楚河    汉界</span></div>
            <div class="pieces-layer" id="pieces-layer"></div>
          </div>
          <div class="turn-indicator" id="turn-indicator">
            <div class="dot"></div>
            <div>等待开始...</div>
          </div>
        </section>
        <aside class="side-panel">
          <div class="section">
            <div class="section-title">房间 / 分享</div>
            <div class="room-controls">
              <label>
                你的昵称
                <input type="text" id="player-name" placeholder="例如：DESLET 或 小李" />
              </label>
              <div class="button-row">
                <button id="create-room">创建房间</button>
                <button class="secondary" id="join-room">加入房间</button>
              </div>
              <label>
                房间号 / 分享链接
                <div style="display: flex; gap: 4px;">
                    <input type="text" id="room-id" placeholder="创建后自动生成" />
                    <button class="secondary small" id="copy-link">复制链接</button>
                </div>
              </label>
              <div class="hint" id="room-hint">提示：创建房间后，将链接发给朋友即可开始实时对战。</div>
            </div>
          </div>

          <div class="section">
            <div class="section-title">对局控制</div>
            <div class="game-controls">
              <div class="capsule-row">
                <span class="pill red" id="red-info">红方：未就绪</span>
                <span class="pill black" id="black-info">黑方：未就绪</span>
                <span class="pill muted" id="status-pill">等待房间...</span>
              </div>
              <div class="button-row">
                <button id="start-game" disabled>开始新局</button>
                <button class="secondary" id="reset-local">断开重连</button>
              </div>
              <div class="button-row">
                <button class="secondary" id="undo-move" disabled>悔棋（剩余 <span id="undo-count">3</span> 次）</button>
                <button class="secondary" id="offer-draw" disabled>求和</button>
              </div>
              <div class="button-row">
                <button class="secondary" id="save-game">封盘 / 存档</button>
                <button class="secondary" id="load-game">续盘 / 载入</button>
              </div>
              <div class="hint">说明：实时对战模式下，走子与悔棋将实时同步。存档功能可保存当前局面。</div>
            </div>
          </div>

          <div class="section">
            <div class="section-title">对局记录</div>
            <div class="log" id="log"></div>
            <div class="footer-note">基于 P2P 技术实现，无需中间服务器，保护对局隐私。</div>
          </div>
        </aside>
      </main>
    </div>

    <script>
      // ===== 状态管理 =====
      const initialBoard = [
        ['r', 'n', 'b', 'a', 'k', 'a', 'b', 'n', 'r'],
        Array(9).fill(null),
        [null, 'c', null, null, null, null, null, 'c', null],
        ['p', null, 'p', null, 'p', null, 'p', null, 'p'],
        Array(9).fill(null),
        Array(9).fill(null),
        ['P', null, 'P', null, 'P', null, 'P', null, 'P'],
        [null, 'C', null, null, null, null, null, 'C', null],
        Array(9).fill(null),
        ['R', 'N', 'B', 'A', 'K', 'A', 'B', 'N', 'R'],
      ];

      const pieceNames = {
        R: '车', N: '马', B: '相', A: '仕', K: '帅', C: '炮', P: '兵',
        r: '车', n: '马', b: '象', a: '士', k: '将', c: '炮', p: '卒',
      };

      let gameState = {
        board: JSON.parse(JSON.stringify(initialBoard)),
        currentTurn: 'red',
        moveHistory: [],
        undoRemaining: { red: 3, black: 3 },
        status: 'idle', // idle, playing, finished
        localSide: null, // 'red', 'black', or null
        roomId: '',
        redPlayer: '',
        blackPlayer: '',
      };

      let selectedPos = null;
      let peer = null;
      let conn = null;

      // ===== UI 元素 =====
      const boardGrid = document.getElementById('board-grid');
      const piecesLayer = document.getElementById('pieces-layer');
      const logEl = document.getElementById('log');
      const turnIndicator = document.getElementById('turn-indicator');
      const undoCountEl = document.getElementById('undo-count');
      const redInfoEl = document.getElementById('red-info');
      const blackInfoEl = document.getElementById('black-info');
      const statusPillEl = document.getElementById('status-pill');
      const connectionStatusEl = document.getElementById('connection-status');

      const playerNameInput = document.getElementById('player-name');
      const roomIdInput = document.getElementById('room-id');
      const roomHintEl = document.getElementById('room-hint');

      const createRoomBtn = document.getElementById('create-room');
      const joinRoomBtn = document.getElementById('join-room');
      const startGameBtn = document.getElementById('start-game');
      const resetLocalBtn = document.getElementById('reset-local');
      const undoMoveBtn = document.getElementById('undo-move');
      const offerDrawBtn = document.getElementById('offer-draw');
      const saveGameBtn = document.getElementById('save-game');
      const loadGameBtn = document.getElementById('load-game');
      const copyLinkBtn = document.getElementById('copy-link');

      // ===== 通用工具 =====
      function log(message, tag = '系统') {
        const line = document.createElement('div');
        line.className = 'log-line';
        const time = new Date().toTimeString().slice(0, 8);
        line.innerHTML = `<span class="time">[${time}]</span><span class="tag">${tag}</span>${message}`;
        logEl.appendChild(line);
        logEl.scrollTop = logEl.scrollHeight;
      }

      function updateUI() {
        // 更新回合指示器
        const text =
          gameState.status === 'idle'
            ? '等待开始...'
            : gameState.status === 'finished'
            ? '对局已结束'
            : gameState.currentTurn === 'red'
            ? '当前轮到：红方'
            : '当前轮到：黑方';
        turnIndicator.classList.toggle('turn-red', gameState.currentTurn === 'red');
        turnIndicator.classList.toggle('turn-black', gameState.currentTurn === 'black');
        turnIndicator.lastElementChild.textContent = text;
        
        // 更新悔棋次数
        if (gameState.localSide) {
            undoCountEl.textContent = gameState.undoRemaining[gameState.localSide];
        }

        // 更新玩家信息
        redInfoEl.textContent = `红方：${gameState.redPlayer || '未就绪'}`;
        blackInfoEl.textContent = `黑方：${gameState.blackPlayer || '未就绪'}`;

        // 按钮状态
        const isConnected = !!conn && conn.open;
        startGameBtn.disabled = !isConnected || gameState.status === 'playing';
        undoMoveBtn.disabled = !isConnected || gameState.status !== 'playing';
        offerDrawBtn.disabled = !isConnected || gameState.status !== 'playing';
      }

      function isRedPiece(code) { return !!code && code === code.toUpperCase(); }
      function isBlackPiece(code) { return !!code && code === code.toLowerCase(); }

      // ===== 联机逻辑 (PeerJS) =====
      function initPeer(id = null) {
        if (peer) peer.destroy();
        
        peer = id ? new Peer(id) : new Peer();
        
        peer.on('open', (newId) => {
          gameState.roomId = newId;
          roomIdInput.value = newId;
          connectionStatusEl.className = 'online-badge';
          connectionStatusEl.querySelector('span:last-child').textContent = '在线';
          log(`已连接到网络，你的房间ID: ${newId}`, '网络');
          
          // 如果是加入房间，自动连接
          const urlParams = new URLSearchParams(window.location.search);
          const roomParam = urlParams.get('room');
          if (roomParam && !conn) {
            log(`检测到房间链接，正在尝试加入 ${roomParam}...`, '网络');
            joinRoom(roomParam);
          }
        });

        peer.on('connection', (c) => {
          if (conn) {
            c.on('open', () => {
                c.send({ type: 'error', message: '房间已满' });
                setTimeout(() => c.close(), 500);
            });
            return;
          }
          setupConnection(c);
          gameState.localSide = 'red'; // 创建者执红
          gameState.redPlayer = playerNameInput.value || '房主';
          log(`玩家已加入，你执红。`, '房间');
        });

        peer.on('error', (err) => {
          log(`网络错误: ${err.type}`, '错误');
          console.error(err);
        });
      }

      function setupConnection(c) {
        conn = c;
        conn.on('open', () => {
          log('对局连接已建立。', '网络');
          updateUI();
          // 同步我的昵称
          sendData({ 
            type: 'sync_player', 
            name: playerNameInput.value || (gameState.localSide === 'red' ? '房主' : '挑战者'),
            side: gameState.localSide 
          });
        });

        conn.on('data', (data) => {
          handleIncomingData(data);
        });

        conn.on('close', () => {
          log('对方已断开连接。', '网络');
          conn = null;
          updateUI();
        });
      }

      function handleIncomingData(data) {
        switch (data.type) {
          case 'sync_player':
            if (data.side === 'red') gameState.redPlayer = data.name;
            else gameState.blackPlayer = data.name;
            updateUI();
            break;
          case 'start_game':
            gameState.board = JSON.parse(JSON.stringify(initialBoard));
            gameState.currentTurn = 'red';
            gameState.moveHistory = [];
            gameState.undoRemaining = { red: 3, black: 3 };
            gameState.status = 'playing';
            log('对方发起了新对局。', '系统');
            renderPieces();
            break;
          case 'move':
            applyMove(data.move);
            renderPieces();
            break;
          case 'undo':
            applyUndo(data.side);
            renderPieces();
            break;
          case 'chat':
            log(data.message, data.sender);
            break;
          case 'error':
            log(data.message, '系统');
            break;
        }
      }

      function sendData(data) {
        if (conn && conn.open) {
          conn.send(data);
        }
      }

      function createRoom() {
        const name = playerNameInput.value.trim();
        if (!name) { alert('请输入昵称'); return; }
        initPeer();
      }

      function joinRoom(id = null) {
        const targetId = id || roomIdInput.value.trim();
        if (!targetId) { alert('请输入房间号'); return; }
        const name = playerNameInput.value.trim();
        if (!name) { alert('请输入昵称'); return; }

        if (!peer) {
            peer = new Peer();
            peer.on('open', () => {
                const c = peer.connect(targetId);
                setupConnection(c);
                gameState.localSide = 'black'; // 加入者执黑
                gameState.blackPlayer = name;
            });
        } else {
            const c = peer.connect(targetId);
            setupConnection(c);
            gameState.localSide = 'black';
            gameState.blackPlayer = name;
        }
      }

      // ===== 核心棋盘逻辑 =====
      function createGrid() {
        boardGrid.innerHTML = '';
        for (let row = 0; row < 10; row++) {
          for (let col = 0; col < 9; col++) {
            const cell = document.createElement('div');
            cell.className = 'cell-border';
            boardGrid.appendChild(cell);
          }
        }
      }

      function renderPieces() {
        piecesLayer.innerHTML = '';
        for (let row = 0; row < 10; row++) {
          for (let col = 0; col < 9; col++) {
            const code = gameState.board[row][col];
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.dataset.row = row; cell.dataset.col = col;
            if (code) {
              const piece = document.createElement('div');
              const isRed = isRedPiece(code);
              piece.className = 'piece ' + (isRed ? 'red' : 'black');
              
              // 联机判断：只能操作自己一方
              const isMyPiece = (gameState.localSide === 'red' && isRed) || (gameState.localSide === 'black' && !isRed);
              const isMyTurn = gameState.currentTurn === gameState.localSide;
              
              if (!isMyTurn || !isMyPiece) {
                piece.classList.add('enemy-turn');
              }
              
              const span = document.createElement('span');
              span.className = 'piece-label';
              span.textContent = pieceNames[code] || '?';
              piece.appendChild(span);
              cell.appendChild(piece);
            }
            cell.addEventListener('click', onCellClick);
            piecesLayer.appendChild(cell);
          }
        }
        updateUI();
      }

      function onCellClick() {
        if (gameState.status !== 'playing') return;
        const row = parseInt(this.dataset.row, 10);
        const col = parseInt(this.dataset.col, 10);
        const code = gameState.board[row][col];
        const isMyTurn = gameState.currentTurn === gameState.localSide;

        if (!isMyTurn) {
          log('还没轮到你走子。', '提示');
          return;
        }

        if (selectedPos) {
          const { row: sr, col: sc } = selectedPos;
          const selectedCode = gameState.board[sr][sc];

          if (sr === row && sc === col) {
            selectedPos = null;
            renderPieces();
            return;
          }

          // 如果点击自己的其他棋子，切换选中
          const targetIsMine = (gameState.localSide === 'red' && isRedPiece(code)) || 
                               (gameState.localSide === 'black' && isBlackPiece(code));
          if (targetIsMine) {
            selectedPos = { row, col };
            highlightSelected(row, col);
            return;
          }

          if (isLegalMove(selectedCode, sr, sc, row, col)) {
            const move = { sr, sc, tr: row, tc: col };
            applyMove(move);
            sendData({ type: 'move', move });
            selectedPos = null;
            renderPieces();
          } else {
            log('不符合走子规则。', '规则');
          }
        } else {
          if (!code) return;
          const isMine = (gameState.localSide === 'red' && isRedPiece(code)) || 
                         (gameState.localSide === 'black' && isBlackPiece(code));
          if (!isMine) {
            log('请选择自己一方的棋子。', '提示');
            return;
          }
          selectedPos = { row, col };
          highlightSelected(row, col);
        }
      }

      function highlightSelected(row, col) {
        renderPieces();
        const cell = piecesLayer.children[row * 9 + col];
        if (cell) cell.querySelector('.piece')?.classList.add('selected');
      }

      function isLegalMove(code, sr, sc, tr, tc) {
        // 规则实现复用之前的逻辑
        if (sr === tr && sc === tc) return false;
        const isRedSide = isRedPiece(code);
        const dr = tr - sr; const dc = tc - sc;
        const absDr = Math.abs(dr); const absDc = Math.abs(dc);
        const target = gameState.board[tr][tc];
        if (target && (isRedSide ? isRedPiece(target) : isBlackPiece(target))) return false;

        const inPalace = (r, c, isRed) => {
          const colOk = c >= 3 && c <= 5;
          const rowOk = isRed ? r >= 7 && r <= 9 : r >= 0 && r <= 2;
          return colOk && rowOk;
        };

        switch (code.toUpperCase()) {
          case 'R':
            if (dr !== 0 && dc !== 0) return false;
            const sR = dr === 0 ? 0 : dr > 0 ? 1 : -1;
            const sC = dc === 0 ? 0 : dc > 0 ? 1 : -1;
            let r = sr + sR, c = sc + sC;
            while (r !== tr || c !== tc) {
              if (gameState.board[r][c]) return false;
              r += sR; c += sC;
            }
            return true;
          case 'N':
            const patterns = [
              { dr: 2, dc: 1, br: 1, bc: 0 }, { dr: 2, dc: -1, br: 1, bc: 0 },
              { dr: -2, dc: 1, br: -1, bc: 0 }, { dr: -2, dc: -1, br: -1, bc: 0 },
              { dr: 1, dc: 2, br: 0, bc: 1 }, { dr: 1, dc: -2, br: 0, bc: -1 },
              { dr: -1, dc: 2, br: 0, bc: 1 }, { dr: -1, dc: -2, br: 0, bc: -1 },
            ];
            const p = patterns.find((p) => p.dr === dr && p.dc === dc);
            return p && !gameState.board[sr + p.br][sc + p.bc];
          case 'B':
            if (absDr !== 2 || absDc !== 2) return false;
            if (gameState.board[(sr + tr) / 2][(sc + tc) / 2]) return false;
            return isRedSide ? tr >= 5 : tr <= 4;
          case 'A':
            return absDr === 1 && absDc === 1 && inPalace(tr, tc, isRedSide);
          case 'K':
            return absDr + absDc === 1 && inPalace(tr, tc, isRedSide);
          case 'C':
            if (dr !== 0 && dc !== 0) return false;
            const stR = dr === 0 ? 0 : dr > 0 ? 1 : -1;
            const stC = dc === 0 ? 0 : dc > 0 ? 1 : -1;
            let rr = sr + stR, cc = sc + stC, count = 0;
            while (rr !== tr || cc !== tc) {
              if (gameState.board[rr][cc]) count++;
              rr += stR; cc += stC;
            }
            return (!target && count === 0) || (target && count === 1);
          case 'P':
            if (isRedSide) {
              if (tr > sr) return false;
              return sr >= 5 ? (dr === -1 && dc === 0) : (dr === -1 && dc === 0) || (dr === 0 && absDc === 1);
            } else {
              if (tr < sr) return false;
              return sr <= 4 ? (dr === 1 && dc === 0) : (dr === 1 && dc === 0) || (dr === 0 && absDc === 1);
            }
        }
        return false;
      }

      function applyMove(move) {
        const { sr, sc, tr, tc } = move;
        const piece = gameState.board[sr][sc];
        const captured = gameState.board[tr][tc];
        gameState.board[tr][tc] = piece;
        gameState.board[sr][sc] = null;
        gameState.moveHistory.push({ from: { row: sr, col: sc }, to: { row: tr, col: tc }, piece, captured });

        const sideName = isRedPiece(piece) ? '红方' : '黑方';
        log(`${sideName} 走 ${pieceNames[piece]} (${sr},${sc}) → (${tr},${tc})${captured ? '，吃掉 ' + pieceNames[captured] : ''}`, '落子');

        if (captured && captured.toUpperCase() === 'K') {
          gameState.status = 'finished';
          log(`${sideName} 将死对方，对局结束！`, '结束');
        } else {
          gameState.currentTurn = gameState.currentTurn === 'red' ? 'black' : 'red';
        }
      }

      function applyUndo(side) {
        const last = gameState.moveHistory.pop();
        if (last) {
            gameState.board[last.from.row][last.from.col] = last.piece;
            gameState.board[last.to.row][last.to.col] = last.captured || null;
            gameState.undoRemaining[side]--;
            gameState.currentTurn = side;
            log(`${side === 'red' ? '红方' : '黑方'} 悔棋一步。`, '悔棋');
        }
      }

      // ===== 事件绑定 =====
      createRoomBtn.addEventListener('click', createRoom);
      joinRoomBtn.addEventListener('click', () => joinRoom());
      
      startGameBtn.addEventListener('click', () => {
        gameState.status = 'playing';
        gameState.board = JSON.parse(JSON.stringify(initialBoard));
        gameState.currentTurn = 'red';
        gameState.moveHistory = [];
        renderPieces();
        sendData({ type: 'start_game' });
        log('你发起了新对局。', '系统');
      });

      undoMoveBtn.addEventListener('click', () => {
        if (gameState.undoRemaining[gameState.localSide] > 0) {
            applyUndo(gameState.localSide);
            sendData({ type: 'undo', side: gameState.localSide });
            renderPieces();
        } else {
            alert('悔棋次数已用完');
        }
      });

      copyLinkBtn.addEventListener('click', () => {
        const url = new URL(window.location.href);
        url.searchParams.set('room', gameState.roomId);
        navigator.clipboard.writeText(url.toString()).then(() => {
          alert('对战链接已复制到剪贴板，快发给朋友吧！');
        });
      });

      resetLocalBtn.addEventListener('click', () => {
        window.location.reload();
      });

      // 初始化
      createGrid();
      renderPieces();
      
      // 检查自动加入
      const urlParams = new URLSearchParams(window.location.search);
      if (urlParams.has('room')) {
        log('检测到对战邀请，请输入昵称后点击“加入房间”', '系统');
        roomIdInput.value = urlParams.get('room');
      }
    </script>
  </body>
</html>
